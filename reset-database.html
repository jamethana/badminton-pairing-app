<!DOCTYPE html>
<html>
<head>
    <title>Reset Database - Badminton App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px 5px;
            font-size: 16px;
        }
        button:hover {
            background: #0056b3;
        }
        .danger {
            background: #dc3545;
        }
        .danger:hover {
            background: #c82333;
        }
        .warning {
            background: #ffc107;
            color: #000;
        }
        .warning:hover {
            background: #e0a800;
        }
        .success {
            background: #28a745;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .section {
            border: 1px solid #ddd;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }
        .danger-box {
            background: #f8d7da;
            border: 1px solid #f1b0b7;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üóëÔ∏è Database Reset Tool</h1>
        <p>This tool allows you to reset and clean up your Supabase database for the Badminton Pairing App.</p>
        
        <div class="warning-box">
            <strong>‚ö†Ô∏è Warning:</strong> These operations will permanently delete data from your Supabase database. Make sure you understand what each operation does before proceeding.
        </div>
        
        <div class="section">
            <h3>üìä Current Database Status</h3>
            <button onclick="loadStats()" class="success">Refresh Database Stats</button>
            
            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="stat-number" id="playersCount">-</div>
                    <div class="stat-label">Players</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="sessionsCount">-</div>
                    <div class="stat-label">Sessions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="matchesCount">-</div>
                    <div class="stat-label">Matches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="eloHistoryCount">-</div>
                    <div class="stat-label">ELO History</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="sessionPlayersCount">-</div>
                    <div class="stat-label">Session Players</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h3>üßπ Selective Cleanup</h3>
            <p>Clean up specific types of data while preserving others:</p>
            
            <button onclick="clearMatches()" class="warning">Clear All Matches</button>
            <button onclick="clearEloHistory()" class="warning">Clear ELO History</button>
            <button onclick="clearSessionPlayers()" class="warning">Clear Session Players</button>
            <button onclick="clearInactiveSessions()" class="warning">Clear Inactive Sessions</button>
            <button onclick="resetPlayerStats()" class="warning">Reset Player Stats</button>
        </div>
        
        <div class="section">
            <h3>üí• Complete Reset</h3>
            <div class="danger-box">
                <strong>üö® Danger Zone:</strong> These operations will delete ALL data and cannot be undone.
            </div>
            
            <button onclick="resetDatabase()" class="danger">Reset Entire Database</button>
            <button onclick="resetKeepPlayers()" class="danger">Reset Everything (Keep Players)</button>
        </div>
        
        <div class="section">
            <h3>üîß Maintenance</h3>
            <p>Database maintenance and optimization:</p>
            
            <button onclick="cleanupDuplicates()" class="success">Remove Duplicates</button>
            <button onclick="optimizeDatabase()" class="success">Optimize Database</button>
            <button onclick="validateData()" class="success">Validate Data Integrity</button>
        </div>
        
        <div id="log" class="log">Click "Refresh Database Stats" to see current state...</div>
        
        <div class="section">
            <h3>üìù Instructions</h3>
            <ul>
                <li><strong>Refresh Database Stats:</strong> Shows current data counts</li>
                <li><strong>Clear Matches:</strong> Removes all match records and history</li>
                <li><strong>Clear ELO History:</strong> Removes ELO progression data</li>
                <li><strong>Clear Session Players:</strong> Removes session membership records</li>
                <li><strong>Reset Player Stats:</strong> Resets all player statistics to zero</li>
                <li><strong>Reset Entire Database:</strong> Deletes ALL data (nuclear option)</li>
                <li><strong>Reset Keep Players:</strong> Deletes everything except player identities</li>
            </ul>
        </div>
    </div>

    <script>
        // Get Supabase credentials - will be loaded from the main app's config
        let SUPABASE_URL = null;
        let SUPABASE_KEY = null;
        
        // Try to get credentials from localStorage (set by main app)
        const getCredentials = () => {
            try {
                // Check if main app has stored the config
                const config = localStorage.getItem('supabase_config');
                if (config) {
                    const parsed = JSON.parse(config);
                    SUPABASE_URL = parsed.url;
                    SUPABASE_KEY = parsed.key;
                    return true;
                }
            } catch (error) {
                console.error('Error reading config:', error);
            }
            
            // Fallback to manual entry
            SUPABASE_URL = prompt('Enter your Supabase URL (from .env.local):');
            SUPABASE_KEY = prompt('Enter your Supabase Anon Key (from .env.local):');
            
            if (SUPABASE_URL && SUPABASE_KEY) {
                // Store for future use
                try {
                    localStorage.setItem('supabase_config', JSON.stringify({
                        url: SUPABASE_URL,
                        key: SUPABASE_KEY
                    }));
                } catch (error) {
                    console.error('Error storing config:', error);
                }
                return true;
            }
            
            return false;
        };
        
        // Load credentials
        if (!getCredentials()) {
            alert('‚ùå Supabase credentials required. Please provide your credentials from .env.local');
            document.body.innerHTML = '<div style="text-align:center;margin-top:100px;"><h2>‚ùå Configuration Required</h2><p>Please provide your Supabase credentials from .env.local file.</p><button onclick="location.reload()">Try Again</button></div>';
        }
        
        const log = document.getElementById('log');
        
        function logMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            log.textContent += `[${timestamp}] ${message}\n`;
            log.scrollTop = log.scrollHeight;
        }
        
        async function supabaseRequest(method, endpoint, data = null) {
            const options = {
                method,
                headers: {
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`,
                    'Content-Type': 'application/json'
                }
            };
            
            if (data && (method === 'POST' || method === 'PATCH')) {
                options.body = JSON.stringify(data);
            }
            
            const response = await fetch(`${SUPABASE_URL}/rest/v1/${endpoint}`, options);
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            return method === 'GET' ? await response.json() : response;
        }
        
        async function loadStats() {
            try {
                logMessage('Loading database statistics...');
                
                const [players, sessions, matches, eloHistory, sessionPlayers] = await Promise.all([
                    supabaseRequest('GET', 'players'),
                    supabaseRequest('GET', 'sessions'),
                    supabaseRequest('GET', 'matches'),
                    supabaseRequest('GET', 'elo_history'),
                    supabaseRequest('GET', 'session_players')
                ]);
                
                document.getElementById('playersCount').textContent = players.length;
                document.getElementById('sessionsCount').textContent = sessions.length;
                document.getElementById('matchesCount').textContent = matches.length;
                document.getElementById('eloHistoryCount').textContent = eloHistory.length;
                document.getElementById('sessionPlayersCount').textContent = sessionPlayers.length;
                
                logMessage(`üìä Database Stats:`);
                logMessage(`  Players: ${players.length}`);
                logMessage(`  Sessions: ${sessions.length}`);
                logMessage(`  Matches: ${matches.length}`);
                logMessage(`  ELO History: ${eloHistory.length}`);
                logMessage(`  Session Players: ${sessionPlayers.length}`);
                
                // Show additional stats
                const activeSessions = sessions.filter(s => s.is_active);
                const completedMatches = matches.filter(m => m.completed_at);
                const cancelledMatches = matches.filter(m => m.cancelled_at);
                const incompleteMatches = matches.filter(m => !m.completed_at && !m.cancelled_at);
                
                logMessage(`üìà Detailed Stats:`);
                logMessage(`  Active Sessions: ${activeSessions.length}`);
                logMessage(`  Completed Matches: ${completedMatches.length}`);
                logMessage(`  Cancelled Matches: ${cancelledMatches.length}`);
                logMessage(`  Incomplete Matches: ${incompleteMatches.length}`);
                
            } catch (error) {
                logMessage(`‚ùå Error loading stats: ${error.message}`);
            }
        }
        
        async function clearMatches() {
            if (!confirm('Delete ALL matches and match history? This cannot be undone.')) return;
            
            try {
                logMessage('üóëÔ∏è Clearing all matches...');
                await supabaseRequest('DELETE', 'matches');
                logMessage('‚úÖ All matches deleted');
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error clearing matches: ${error.message}`);
            }
        }
        
        async function clearEloHistory() {
            if (!confirm('Delete ALL ELO history? Player progression data will be lost.')) return;
            
            try {
                logMessage('üóëÔ∏è Clearing ELO history...');
                await supabaseRequest('DELETE', 'elo_history');
                logMessage('‚úÖ ELO history cleared');
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error clearing ELO history: ${error.message}`);
            }
        }
        
        async function clearSessionPlayers() {
            if (!confirm('Delete ALL session player relationships? Players will need to be re-added to sessions.')) return;
            
            try {
                logMessage('üóëÔ∏è Clearing session players...');
                await supabaseRequest('DELETE', 'session_players');
                logMessage('‚úÖ Session players cleared');
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error clearing session players: ${error.message}`);
            }
        }
        
        async function clearInactiveSessions() {
            if (!confirm('Delete all inactive/ended sessions? Only active sessions will remain.')) return;
            
            try {
                logMessage('üóëÔ∏è Clearing inactive sessions...');
                await supabaseRequest('DELETE', 'sessions?is_active=eq.false');
                logMessage('‚úÖ Inactive sessions cleared');
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error clearing inactive sessions: ${error.message}`);
            }
        }
        
        async function resetPlayerStats() {
            if (!confirm('Reset ALL player statistics to zero? Names will be kept but all stats will be lost.')) return;
            
            try {
                logMessage('üîÑ Resetting player statistics...');
                await supabaseRequest('PATCH', 'players', {
                    total_matches: 0,
                    total_wins: 0,
                    total_losses: 0,
                    current_elo: 100,
                    highest_elo: 100,
                    lowest_elo: 100,
                    last_match_at: null
                });
                logMessage('‚úÖ Player statistics reset');
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error resetting player stats: ${error.message}`);
            }
        }
        
        async function resetDatabase() {
            const confirmation = prompt('Type "DELETE EVERYTHING" to confirm complete database reset:');
            if (confirmation !== 'DELETE EVERYTHING') {
                logMessage('‚ùå Reset cancelled - confirmation failed');
                return;
            }
            
            try {
                logMessage('üí• RESETTING ENTIRE DATABASE...');
                
                // Delete in order to respect foreign key constraints
                logMessage('üóëÔ∏è Deleting ELO history...');
                await supabaseRequest('DELETE', 'elo_history');
                
                logMessage('üóëÔ∏è Deleting match events...');
                await supabaseRequest('DELETE', 'match_events');
                
                logMessage('üóëÔ∏è Deleting matches...');
                await supabaseRequest('DELETE', 'matches');
                
                logMessage('üóëÔ∏è Deleting session players...');
                await supabaseRequest('DELETE', 'session_players');
                
                logMessage('üóëÔ∏è Deleting courts...');
                await supabaseRequest('DELETE', 'courts');
                
                logMessage('üóëÔ∏è Deleting session settings...');
                await supabaseRequest('DELETE', 'session_settings');
                
                logMessage('üóëÔ∏è Deleting sessions...');
                await supabaseRequest('DELETE', 'sessions');
                
                logMessage('üóëÔ∏è Deleting players...');
                await supabaseRequest('DELETE', 'players');
                
                logMessage('‚úÖ COMPLETE DATABASE RESET SUCCESSFUL');
                logMessage('üîÑ Database is now empty - you can start fresh');
                
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error during reset: ${error.message}`);
            }
        }
        
        async function resetKeepPlayers() {
            if (!confirm('Reset everything but keep player identities? All matches, sessions, and stats will be lost.')) return;
            
            try {
                logMessage('üîÑ Resetting database (keeping players)...');
                
                // Delete everything except players
                logMessage('üóëÔ∏è Deleting ELO history...');
                await supabaseRequest('DELETE', 'elo_history');
                
                logMessage('üóëÔ∏è Deleting matches...');
                await supabaseRequest('DELETE', 'matches');
                
                logMessage('üóëÔ∏è Deleting session players...');
                await supabaseRequest('DELETE', 'session_players');
                
                logMessage('üóëÔ∏è Deleting sessions...');
                await supabaseRequest('DELETE', 'sessions');
                
                logMessage('üîÑ Resetting player statistics...');
                await supabaseRequest('PATCH', 'players', {
                    total_matches: 0,
                    total_wins: 0,
                    total_losses: 0,
                    current_elo: 100,
                    highest_elo: 100,
                    lowest_elo: 100,
                    last_match_at: null
                });
                
                logMessage('‚úÖ Database reset complete (players preserved)');
                await loadStats();
            } catch (error) {
                logMessage(`‚ùå Error during reset: ${error.message}`);
            }
        }
        
        async function cleanupDuplicates() {
            try {
                logMessage('üßπ Cleaning up duplicate records...');
                
                // This would require more complex logic to identify and remove duplicates
                // For now, just log what we would do
                logMessage('üîç Analyzing for duplicates...');
                
                const players = await supabaseRequest('GET', 'players');
                const sessions = await supabaseRequest('GET', 'sessions');
                
                // Check for duplicate player names
                const playerNames = {};
                let duplicatePlayers = 0;
                players.forEach(player => {
                    if (playerNames[player.name]) {
                        duplicatePlayers++;
                    } else {
                        playerNames[player.name] = true;
                    }
                });
                
                // Check for duplicate session names
                const sessionNames = {};
                let duplicateSessions = 0;
                sessions.forEach(session => {
                    if (sessionNames[session.name]) {
                        duplicateSessions++;
                    } else {
                        sessionNames[session.name] = true;
                    }
                });
                
                logMessage(`üìä Duplicate Analysis:`);
                logMessage(`  Duplicate players by name: ${duplicatePlayers}`);
                logMessage(`  Duplicate sessions by name: ${duplicateSessions}`);
                
                if (duplicatePlayers === 0 && duplicateSessions === 0) {
                    logMessage('‚úÖ No duplicates found');
                } else {
                    logMessage('‚ö†Ô∏è Duplicates detected - manual cleanup may be needed');
                }
                
            } catch (error) {
                logMessage(`‚ùå Error during cleanup: ${error.message}`);
            }
        }
        
        async function optimizeDatabase() {
            try {
                logMessage('‚ö° Optimizing database...');
                
                // Clean up incomplete matches older than 24 hours
                const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
                const oldIncompleteMatches = await supabaseRequest('GET', 
                    `matches?completed_at=is.null&cancelled_at=is.null&started_at=lt.${oneDayAgo}`);
                
                if (oldIncompleteMatches.length > 0) {
                    logMessage(`üóëÔ∏è Cleaning up ${oldIncompleteMatches.length} old incomplete matches...`);
                    await supabaseRequest('DELETE', 
                        `matches?completed_at=is.null&cancelled_at=is.null&started_at=lt.${oneDayAgo}`);
                    logMessage(`‚úÖ Removed ${oldIncompleteMatches.length} stale matches`);
                }
                
                // Mark inactive sessions as ended
                const activeSessions = await supabaseRequest('GET', 'sessions?is_active=eq.true&ended_at=is.null');
                let updatedSessions = 0;
                
                for (const session of activeSessions) {
                    // Check if session has recent activity (matches in last 24 hours)
                    const recentMatches = await supabaseRequest('GET', 
                        `matches?session_id=eq.${session.id}&started_at=gte.${oneDayAgo}`);
                    
                    if (recentMatches.length === 0) {
                        await supabaseRequest('PATCH', `sessions?id=eq.${session.id}`, {
                            is_active: false,
                            ended_at: new Date().toISOString()
                        });
                        updatedSessions++;
                    }
                }
                
                if (updatedSessions > 0) {
                    logMessage(`‚úÖ Marked ${updatedSessions} inactive sessions as ended`);
                }
                
                logMessage('‚úÖ Database optimization complete');
                await loadStats();
                
            } catch (error) {
                logMessage(`‚ùå Error during optimization: ${error.message}`);
            }
        }
        
        async function validateData() {
            try {
                logMessage('üîç Validating data integrity...');
                
                const [players, sessions, matches, sessionPlayers] = await Promise.all([
                    supabaseRequest('GET', 'players'),
                    supabaseRequest('GET', 'sessions'),
                    supabaseRequest('GET', 'matches'),
                    supabaseRequest('GET', 'session_players')
                ]);
                
                let issues = 0;
                
                // Check for matches with invalid player references
                for (const match of matches) {
                    const playerIds = [
                        match.team1_player1_id,
                        match.team1_player2_id,
                        match.team2_player1_id,
                        match.team2_player2_id
                    ].filter(Boolean);
                    
                    for (const playerId of playerIds) {
                        if (!players.find(p => p.id === playerId)) {
                            logMessage(`‚ùå Match ${match.id} references non-existent player ${playerId}`);
                            issues++;
                        }
                    }
                }
                
                // Check for session players with invalid references
                for (const sp of sessionPlayers) {
                    if (!players.find(p => p.id === sp.player_id)) {
                        logMessage(`‚ùå Session player record references non-existent player ${sp.player_id}`);
                        issues++;
                    }
                    if (!sessions.find(s => s.id === sp.session_id)) {
                        logMessage(`‚ùå Session player record references non-existent session ${sp.session_id}`);
                        issues++;
                    }
                }
                
                if (issues === 0) {
                    logMessage('‚úÖ Data integrity validation passed - no issues found');
                } else {
                    logMessage(`‚ö†Ô∏è Found ${issues} data integrity issues`);
                }
                
            } catch (error) {
                logMessage(`‚ùå Error during validation: ${error.message}`);
            }
        }
        
        // Auto-load stats on page load
        loadStats();
    </script>
</body>
</html>
